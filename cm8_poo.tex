\documentclass[10pt]{beamer}

\usetheme[%
    progressbar=frametitle,
    block=fill,
    numbering=fraction,
    footer=crumbs,
    sectionpage=numbered,
    subsectionpage=none,
    titleformattitle=smallcaps,
    titleformatsubtitle=smallcaps,
    %%% new options for UR2 theme:
    maincolor=red,
]{metropolis-ur2}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=.,
    filecolor=ur2Turquoise,
    urlcolor=ur2Bleu,
    pdftitle={M1 MAS - Python - Programmation Orientée Objet},
    pdfpagemode=FullScreen,
}

% \usepackage{biblatex}
% \addbibresource{example.bib}

\usepackage{appendixnumberbeamer}
\usepackage{adjustbox}
\usepackage{booktabs}
\usepackage{fontawesome5}
\usepackage{graphicx}
\usepackage{array}
\usepackage{tabularx}
\usepackage{myminted}
% \usepackage[cache=false]{minted}

\title[M1 MAS -- Python -- POO]{CM 8a - La Programmation Orientée Objet}
\subtitle{Programmation Python -- Master 1 MAS}
\author{Romain Tavenard}
\date{2025}
\institute{%
\hypersetup{urlcolor=.}
\makebox[2.2ex][c]{\faEnvelope}\enspace\href{mailto:romain.tavenard@univ-rennes2.fr}{\texttt{romain.tavenard@univ-rennes2.fr}}\\%
% \makebox[2.2ex][c]{\faHome}\enspace\url{https://rtavenar.github.io/}%
}

\begin{document}

\maketitle

\section{Vocabulaire}

\begin{frame}[fragile]{Constructeur}
  \begin{beamercodeblock}
    \begin{minted}[fontsize=\footnotesize]{python}
      class MaClasseTropClasse:
        def __init__(self):
          self.a = 123

      o = MaClasseTropClasse()
    \end{minted}
  \end{beamercodeblock}

  Que vaut \mintinline{python}|o.a| ici ?

  \begin{beamercodeblock}
    \begin{minted}[fontsize=\footnotesize]{python}
      class MaClasseTropClasse:
        def __init__(self, x):
          self.a = 123 + x

      o = MaClasseTropClasse(12)
    \end{minted}
  \end{beamercodeblock}

  Que vaut \mintinline{python}|o.a| ici ?
\end{frame}

\begin{frame}[fragile]{Propriétes \& Méthodes}
  \begin{beamercodeblock}
    \begin{minted}[fontsize=\footnotesize]{python}
      class MaClasseTropClasse:
        def __init__(self):
          self.a = 123          # Propriété (== attribut)
        
        def f(self, b):         # Méthode
          return b + self.a - 4

        @property
        def double_de_a(self):  # Propriété (calculée)
          return 2 * self.a

      o = MaClasseTropClasse()
      print(o.a)
      print(o.f(0))
      print(o.double_de_a)
    \end{minted}
  \end{beamercodeblock}
\end{frame}

% \begin{frame}[fragile]{Propriétes / Attributs de classe}
%   \begin{beamercodeblock}
%     \begin{minted}[fontsize=\footnotesize]{python}
% class MaClasseTropClasse:
%   n_objets_crees = 0

%   def __init__(self):
%     self.a = 123          # Propriété (== attribut)
%     MaClasseTropClasse.n_objets_crees += 1

% o = MaClasseTropClasse()
% print(MaClasseTropClasse.n_objets_crees)

% o2 = MaClasseTropClasse()
% print(MaClasseTropClasse.n_objets_crees)
%     \end{minted}
%   \end{beamercodeblock}
% \end{frame}

% \begin{frame}[fragile]{Méthodes de classe}
%   On peut aussi avoir des méthodes de classe : elles ne peuvent accéder qu'aux attributs de classe.

%   \begin{beamercodeblock}
%     \begin{minted}[fontsize=\footnotesize]{python}
% class MaClasseTropClasse:
%   n_objets_crees = 0
%   def __init__(self):
%     self.a = 123          # Propriété (== attribut)
%     MaClasseTropClasse.n_objets_crees += 1
%   @classmethod
%   def print_n_objets(cls):
%     print(cls.n_objets_crees)

% o = MaClasseTropClasse()
% o2 = MaClasseTropClasse()
% MaClasseTropClasse.print_n_objets()
%     \end{minted}
%   \end{beamercodeblock}
% \end{frame}

% \begin{frame}[fragile]{Méthodes de classe, méthodes statiques}
%   On peut aussi avoir des méthodes statiques : elles ne peuvent accéder ni aux attributs d'instance ni aux attributs de classe.

%   \begin{beamercodeblock}
%     \begin{minted}[fontsize=\footnotesize]{python}
% class MaClasseTropClasse:
%   n_objets_crees = 0
%   def __init__(self):
%     self.a = 123          # Propriété (== attribut)
%     MaClasseTropClasse.n_objets_crees += 1
%   @staticmethod
%   def compare(objet1, objet2):
%     print(f"Les valeurs respectives de a sont {objet1.a} et {objet2.a}")

% o = MaClasseTropClasse()
% o2 = MaClasseTropClasse()
% o2.a = 55
% MaClasseTropClasse.compare(o, o2)
%     \end{minted}
%   \end{beamercodeblock}
% \end{frame}

\begin{frame}[fragile]{Exercice de synthèse}
  \begin{quote}
    Implémentez une classe \mintinline{python}|NombreComplexe| telle que l'on puisse exécuter le code suivant :
    \begin{beamercodeblock}
      \begin{minted}[fontsize=\footnotesize]{python}
        c0 = NombreComplexe(10, 0)  # 10
        c1 = NombreComplexe(0, 5)   # 5i
        c2 = NombreComplexe(3, -2)  # 3 - 2i
        print(c1.module())          # Affiche 5
        print(c0.distance(c1))     # Affiche 11.18...
      \end{minted}
    \end{beamercodeblock}
  \end{quote}
\end{frame}

\section{Surcharge d'opérateur}

\begin{frame}[fragile]{Les opérateurs en Python}
  Que se passe-t-il lorsqu'on écrit \mintinline{python}|a + b| en Python ?

  \pause

  L'interpréteur\dots
  \begin{enumerate}
    \item recherche la classe de \mintinline{python}|a|
    \item examine cette classe pour trouver une méthode spéciale \mintinline{python}|__add__|
    \item appelle cette méthode, comme si on avait écrit \mintinline{python}|a.__add__(b)|
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Surcharge d'opérateur : exemple}
  \begin{beamercodeblock}
    \begin{minted}[fontsize=\footnotesize]{python}
      class MaClasseTropClasse:
        def __init__(self, x=0):
          self.a = 123 + x
        
        def __add__(self, autre):
          return self.a + autre.a

      o1 = MaClasseTropClasse()
      o2 = MaClasseTropClasse(10)
    \end{minted}
  \end{beamercodeblock}

  Que vaut \mintinline{python}|o1 + o2| ici ?
\end{frame}

\begin{frame}[fragile]{Exercice de synthèse}
  \begin{quote}
    Reprenez votre classe \mintinline{python}|NombreComplexe| et implémentez l'opérateur d'addition :
    \begin{beamercodeblock}
      \begin{minted}[fontsize=\footnotesize]{python}
        c0 = NombreComplexe(10, 0)  # 10
        c1 = NombreComplexe(0, 5)   # 5i
        c2 = c0 + c1                # c2 doit être de classe NombreComplexe
      \end{minted}
    \end{beamercodeblock}
  \end{quote}
\end{frame}

\begin{frame}[fragile]{Les opérateurs en Python}
  À quoi servent les opérateurs suivants ?
  
  \begin{enumerate}
    % \item \mintinline{python}|__radd__|
    %   \pause
    \item \mintinline{python}|__mul__| % / \mintinline{python}|__rmul__| 
    \pause
    \item \mintinline{python}|__sub__| %/ \mintinline{python}|__rsub__|
    \pause
    \item \mintinline{python}|__truediv__| / \mintinline{python}|__floordiv__|
    \pause
    \item \mintinline{python}|__repr__|
    % \pause
    % \item \mintinline{python}|__contains__|
  \end{enumerate}
\end{frame}

\end{document}
